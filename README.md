# Задачи решенные по курсу "Белый пояс по С++" от Яндекса на платформе Курсера
## Неделя №1
1. **Hello**
> Печатает фразу в консоль
2. **Sum**
>  Печатает сумму двух чисел в консоль
3. **Minimal-naia-stroka**
> Вывод лексикографически минимальной строки из данных в консоль
4. **Uravnieniie**
> На вход вашей программы в стандартном потоке ввода подаются действительные коэффициенты A, B и C уравнения Ax² + Bx + C = 0. Выведите все его различные действительные корни в поток вывода в любом порядке, при этом разделяя корни пробелами. Гарантируется, что хотя бы один из коэффициентов уравнения не равен нулю.
5. **Dielieniie**
> Дано два целых числа A и B в диапазоне от 0 до 1 000 000 включительно. Напишите программу, которая вычисляет целую часть частного от деления A на B.
6. **Raschiot-stoimosti-tovara**
> Написать программу вычисления стоимости покупки товара с учётом скидки. Если исходная стоимость товара больше A рублей, то на неё устанавливается скидка в X процентов. Если исходная стоимость товара больше B рублей, то на неё устанавливается скидка в Y процентов.
На вход программе даны пять вещественных чисел: N, A, B, X, Y (A < B) - где N - исходная стоимость товара. Выведите стоимость покупки товара с учётом скидки.
7. **Chiotnyie-chisla**
> Дано два целых числа A и B (A <= B, A >= 1, B <= 30000). Выведите через пробел все чётные числа от A до B (включительно).
8. **Vtoroie-vkhozhdieniie**
> Дана строка. Найдите в этой строке второе вхождение буквы f и выведите индекс этого вхождения. Если буква f в данной строке встречается только один раз, выведите число -1, а если не встречается ни разу, выведите число -2. Индексы нумеруются с нуля.
9. **Naibol-shii-obshchii-dielitiel**
> В stdin даны два натуральных числа. Выведите в stdout их наибольший общий делитель.С использованием алгоритма Евклида
10. **Dvoichnyie-chisla**
> На вход дано целое положительное число N. Выведите его в двоичной системе счисления без ведущих нулей.

## Неделя №2
1. **Factorial**
> Принимает int и возвращает факториал своего аргумента. Гарантируется, что аргумент функции по модулю не превышает 10. Для отрицательных аргументов функция должна возвращать 1.
2. **Palindrom**
> принимает параметр типа string и возвращает, является ли переданная строка палиндромом
3. **PalindromFilter**
> принимает vector<string> words и int minLength и возвращает все строки из вектора words, которые являются палиндромами и имеют длину не меньше minLength
4. **UpdateIfGreater**
> Напишите функцию UpdateIfGreater, которая принимает два целочисленных аргумента: first и second. Если first оказался больше second, Ваша функция должна записывать в second значение параметра first. При этом указанная функция не должна ничего возвращать, а изменение параметра second должно быть видно на вызывающей стороне.
5. **MoveStrings**
> Напишите функцию MoveStrings, которая принимает два вектора строк, source и destination, и дописывает все строки из первого вектора в конец второго. После выполнения функции вектор source должен оказаться пустым.
6. **Reverse**
> Реализуйте функцию void Reverse(vector<int>& v), которая переставляет элементы вектора в обратном порядке.
7. **Reversed**
> Реализуйте функцию vector<int> Reversed(const vector<int>& v), возвращающую копию вектора v, в которой числа переставлены в обратном порядке.
8. **Sriedniaia-tiempieratura**
> Даны значения температуры, наблюдавшиеся в течение N подряд идущих дней. Найдите номера дней (в нумерации с нуля) со значением температуры выше среднего арифметического за все N дней.
9. **Ochieried**
> Люди стоят в очереди, но никогда не уходят из её начала, зато могут приходить в конец и уходить оттуда. Более того, иногда некоторые люди могут прекращать и начинать беспокоиться из-за того, что очередь не продвигается.
10. **Iezhiemiesiachnyie-diela**
> У каждого из нас есть повторяющиеся ежемесячные дела, каждое из которых нужно выполнять в конкретный день каждого месяца: оплата счетов за электричество, абонентская плата за связь и пр. Вам нужно реализовать работу со списком таких дел на месяц, а именно, реализовать набор следующих операций
11. **Avtobusnyie-ostanovki-1**
> Реализуйте систему хранения автобусных маршрутов. Вам нужно обрабатывать следующие запросы:
12. **Avtobusnyie-ostanovki-1**
> В этой задаче вам нужно присваивать номера автобусным маршрутам. А именно, для каждого маршрута, заданного набором названий остановок, нужно либо выдать новый номер (первому маршруту — 1, второму — 2 и т. д.), либо вернуть номер существующего маршрута, которому соответствует такой набор остановок.
13. **kolichiestvo-unikal-nykh-strok**
> Дан набор строк. Найдите количество уникальных строк в этом наборе.
14. **mnozhiestvo-znachienii-slovaria**
> Напишите функцию BuildMapValuesSet, принимающую на вход словарь map<int, string> и возвращающую множество значений этого словаря:
15. **sinonimy**
> Два слова называются синонимами друг друга, если они имеют похожие значения. Реализуйте следующие операции над словарём синонимов:
16. **avtobusnyie-ostanovki-3**
> В этой задаче вам нужно присваивать номера автобусным маршрутам.
## Неделя №3
1. **Sortirovka-tsielykh-chisiel-po-moduliu**
> В стандартном потоке дана одна строка, состоящая из N + 1 целых чисел. Первым числом идёт само число N. Далее следуют ещё N чисел, обозначим их за массив A. Между собой числа разделены пробелом.
2. **sortirovka-biez-uchiota-rieghistra**
> Отсортируйте строки S в лексикографическом порядке по возрастанию, игнорируя регистр букв, и выведите их в стандартный поток вывода.
3. **imiena-i-familii-1**
> Реализуйте класс для человека, поддерживающий историю изменений человеком своих фамилии и имени.
4. **imiena-i-familii-2**
> Дополните класс из предыдущей задачи «Имена и фамилии — 1» методом GetFullNameWithHistory:
5. **Stroka**
> Реализуйте класс ReversibleString, хранящий строку и поддерживающий методы Reverse для переворота строки и ToString для получения строки.
6. **imiena-i-familii-3**
> Дополните класс Person из задачи «Имена и фамилии — 2» конструктором, позволяющим задать имя и фамилию человека при рождении, а также сам год рождения. Класс не должен иметь конструктора по умолчанию.
7. **sposoby-initsializatsii**
> Определите тип Incognizable, для которого следующий код будет корректен:
## Неделя №4
1. **struktura-lecturetitle**
> Допишите конструктор и структуры Specialization, Course, Week так, чтобы объект LectureTitle можно было создать с помощью кода
2. **obratimaia-funktsiia**
> Реализуйте рассказанный на лекции класс Function, позволяющий создавать, вычислять и инвертировать функцию, состоящую из следующих элементарных операций:
3. **obratimaia-funktsiia-s-umnozhieniiem-i-dielieniiem**
> Добавьте в класс Function из задачи «Обратимая функция» обработку умножения ('*') и деления ('/'). Гарантируется отсутствие элементарных операций умножения и деления на 0.
4. **rabota-s-failami**
> В этом задании вам предстоит написать две небольшие программы. Каждый пункт - отдельная задача, решение отправляйте в поле с соответствующим номером.
5. **vyvod-s-tochnost-iu**
> В файле input.txt записаны вещественные числа, по одному на строчку. На стандартный вывод напечатайте эти числа в том же порядке, по одному на строке, но сделайте так, чтобы у каждого из них было ровно три знака после десятичной точки.
6. **chtieniie-i-vyvod-tablitsy**
> В первой строке файла input.txt записаны два числа N и M. Далее в файле находится таблица из N строк и M столбцов, представленная в формате CSV (comma-separated values). Такой формат часто используется для текстового представления таблиц с данными: в файле несколько строк, значения из разных ячеек внутри строки отделены друг от друга запятыми. Ваша задача — вывести данные на экран в виде таблицы. Формат таблицы:
7. **spisok-studientov**
> Определите структуру «Студент» со следующими полями: имя, фамилия, день, месяц и год рождения. Создайте вектор из таких структур, заполните его из входных данных и затем по запросам выведите нужные поля.
8. **klass-rational**
> В этой задаче вам надо разработать класс для представления рациональных чисел и внедрить его в систему типов языка С++ так, чтобы им можно было пользоваться естественным образом. Задание состоит из нескольких частей. К каждой части приложен файл с заготовкой программы, который имеет следующую структуру
9. **funktsiia-ensureequal**
> В случае, если строка left не равна строке right, функция должна выбрасывать исключение runtime_error с содержанием "<l> != <r>", где <l> и <r> - строки, которые хранятся в переменных left и right соответственно. Обратите внимание, что вокруг знака неравенства в строке, которая помещается в исключение, должно быть ровно по одному пробелу.
10. **iskliuchieniia-v-klassie-rational**
> Вспомним класс Rational, который мы реализовали в задачах, посвящённых перегрузке операторов. Там специально говорилось, что в тестах объекты класса Rational никогда не создаются с нулевым знаменателем и никогда не выполняется деление на ноль. Настало время избавиться от этого ограничения и научиться обрабатывать нулевой знаменатель и деление на ноль. В этой задаче вам предстоит это сделать.
11. **kal-kuliator-obyknoviennykh-drobiei**
> Итак, теперь у нас с вами есть полноценный тип для представления обыкновенных дробей: класс Rational интегрирован в язык с помощью перегрузки операторов и не позволяет выполнять некорректные операции за счёт выбрасывания исключений. Давайте на основе класса Rational создадим простой калькулятор для обыкновенных дробей.
12. **rabota-s-siervierom-vriemieni**
> Используя функцию AskTimeServer, напишите класс TimeServer со следующим интерфейсом:
## Неделя №5
